# Типы команд. Условные связки

\$? - хранит информацию об успешности выполнения последней команды. 0 - успешно, иначе - ошибка
Для каждой команды коды ошибок свои

Чтобы выполнить команды последовательно, используется **;**

    mkdir directory; echo "hello" >> new_file

В данном случае неважно как завершилась команда **mkdir directory**. Следующая после неё команда всё равно выполнится

Если вместо **;** использовать **||** (связь или), то в случае ошибки выполнения первой команды, вторая команда выполнится в любом случае (выполнение до первой правды)

    mkdir directory || echo "hello" >> new_file

Если первая команда выполнится без ошибок, то вторая команда выполняться не будет. Вышеизложенное актуально не только для последовательности из двух команд

Использование **&&** - выполнение до первой лжи. Если первая команда выполнилась успешно, то следующие команды будут выполняться до тех пор, пока не вернется код ошибки в результате выполнения команды

    mkdir directory && echo "hello" >> new_file

# Потоки ввода-вывода. Конвейер

Передача выходного потока одной команды на вход другой называется конвеёером (pipeline)

Чтобы найти в лог-файле слово GNOME, можно использовать следующие конструкции

    grep GNOME logfile // Обычный вызов команды с аргументами
    cat logfile | grep GNOME // Передача по конвейеру

# Создание простого скрипта. Методы запуска, переменные


    mkdir dir
    mkdir dir2

    echo "hello" >> dir2/file

Скрипт создаёт каталоги dir, dir2 и в каталоге dir2 создаёт файл file с содержимым "hello"

Попробуем модернизировать скрипт добавив условия

Примеры условий представлены ниже в таблице
| Условие                | Тип оператора                      | Описание                 |
| ---------------------- | ---------------------------------- | ------------------------ |
| [[ -z STRING ]]        | Операторы сравнения строк          | Пустая строка            |
| [[ -n STRING ]]        | Операторы сравнения строк          | Не пустая строка         |
| [[ STRING == STRING ]] | Операторы сравнения строк          | Равно                    |
| [[ STRING != STRING ]] | Операторы сравнения строк          | Не равно                 |
| [[ NUM -eq NUM ]]      | Операторы сравнения чисел          | Равно                    |
| [[ NUM -ne NUM ]]      | Операторы сравнения чисел          | Не равно                 |
| [[ NUM -lt NUM ]]      | Операторы сравнения чисел          | Меньше                   |
| [[ NUM -le NUM ]]      | Операторы сравнения чисел          | Меньше или равно         |
| [[ NUM -gt NUM ]]      | Операторы сравнения чисел          | Больше                   |
| [[ NUM -ge NUM ]]      | Операторы сравнения чисел          | Больше или равно         |
| (( NUM < NUM ))        | Операторы сравнения чисел          | Меньше                   |
| [[ STRING =~ STRING ]] | Оператор регулярного выражения     | Соответствие шаблону     |
| [[ -o noclobber ]]     | Оператор проверки свойства         | Проверка свойства        |
| [[ ! EXPR ]]           | Операторы проверки выражений       | Отрицание (инверсия)     |
| [[ X && Y ]]           | Операторы проверки выражений       | Условие И                |
| [[ X \|\| Y ]]         | Операторы проверки выражений       | Условие ИЛИ              |
| [[ -e FILE ]]          | Операторы сравнения файлов и папок | Файл существует          |
| [[ -r FILE ]]          | Операторы сравнения файлов и папок | Файл читаем              |
| [[ -h FILE ]]          | Операторы сравнения файлов и папок | Символьная ссылка        |
| [[ -d FILE ]]          | Операторы сравнения файлов и папок | Директория               |
| [[ -w FILE ]]          | Операторы сравнения файлов и папок | Файл записываемый        |
| [[ -s FILE ]]          | Операторы сравнения файлов и папок | Размер больше 0 байт     |
| [[ -f FILE ]]          | Операторы сравнения файлов и папок | Это файл                 |
| [[ -x FILE ]]          | Операторы сравнения файлов и папок | Исполняемый файл         |
| [[ FILE1 -nt FILE2 ]]  | Операторы сравнения файлов и папок | 1 изменен позднее, чем 2 |
| [[ FILE1 -ot FILE2 ]]  | Операторы сравнения файлов и папок | 2 изменен позднее, чем 1 |
| [[ FILE1 -ef FILE2 ]]  | Операторы сравнения файлов и папок | Одинаковые файлы         |

Важно отметить, что конструкция **[[ ]]** является подпрограммой, которая в результате своего выполнения возвращает 0 (true) или 1 (false)

Теперь улучшим скрипт выше

    mkdir dir
    if [[ $? -ne 0 ]]; then
        exit 1
    
    mkdir dir2
    if [[ $? -ne 0 ]]; then
        exit 2
    
    echo "hello" >> dir2/file


Если не выполнится команда **mkdir dir**, вернется код 1.
Если не выполнится команда **mkdir dir2**, вернется код 2

Обычно, в исполняемых файлах в начале кода указывается путь до программы, которая его будет выполнять. Для начала сделаем файл исполняемым, затем укажем путь к файлу программы, в которой хотим открыть скрипт

    # Добавим бит executable файлу script.sh
    chmod u+x script.sh

    # Добавим путь в файле скрипта
    #!/bin/bash

    mkdir dir
    if [[ $? -ne 0 ]]; then
        exit 1
    
    mkdir dir2
    if [[ $? -ne 0 ]]; then
        exit 2
    
    echo "hello" >> dir2/file

Скрипту можно передавать аргументы. С помощью специальных переменных можно обращаться к переданным аргументам:
- **\$#** - хранит кол-во переданных аргументов
- **\$** - хранит переданные аргументы в виде строки, разделенные пробелом
- **\$@** - хранит переданные аргументы в виде отдельных строк (массив)
- **\$1** - первый переданный аргумент
- **\$_** - последний переданный аргумент

Также стоит поговорить о потоках ввода-вывода из bash. Основные:
- stdin - поток ввода (0)
- stdout - поток вывода (1)
- stderr - поток ошибок (2)

Для перенаправления всех потоков используется конструкция **&>**

Для перенаправления стандартного вывода - **"1 >> имя_файла"** или **"1 > имя_файла"**, для перенаправления ошибок - **"2 >> имя_файла"** или **"2 > имя_файла"**

Для подавления вывода необходимо вместо имени файла использовать путь /dev/nul, например, **"1 > /dev/null"**, **"2 >> /dev/null"**, **"& > /dev/null"**

Также в bash можно использовать циклы for, while, создавать функции и многое другое

В итоге, наш первоначальный скрипт можно преобразовать следующим образом

    #! /bin/bash

    for i in $@; do
        mkdir -p $i &> /dev/null
        if [[ $? -ne 0 ]]; then
            echo "Ошибка при создании каталога ${i}"
            fi
    done
    exit 0

Теперь при вызове файла script.sh с аргументами qqqq wwww eeee мы получим своё собственное сообщение об ошибке с указанием конкретного каталога, если у нас нет прав на создание каталогов, или вывода не будет, если всё прошло успешно

Раскрытие строки (вызов переменной из строки с её именем)

    a = "b"
    b = 123

    echo ${!a} # Результат: 123

